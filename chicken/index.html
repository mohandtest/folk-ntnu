<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chicken</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
        }
    </style>
    <!-- Use a single script that includes all Three.js components -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Add GLTFLoader separately -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
</head>
<body>
    <div class="loading-text">Loading 3D Chicken Model...</div>
    
    <script>
        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Light blue sky background

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 5);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Add ground - updating to grass texture
        const groundGeometry = new THREE.PlaneGeometry(10, 10, 32, 32);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4CAF50,  // Green color for grass
            roughness: 0.8,
            metalness: 0.1,
            flatShading: false
        });
        
        // Add some vertex displacement to make it look more like grass
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            // Only modify y values (height) and keep edges flat
            if (i > 100 && i < vertices.length - 100) {
                vertices[i + 1] = Math.random() * 0.05; // Small random height
            }
        }
        groundGeometry.attributes.position.needsUpdate = true;
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Add fences around the perimeter
        function createFences() {
            const fenceGroup = new THREE.Group();
            
            // Fence post geometry and material
            const postGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
            const railGeometry = new THREE.BoxGeometry(2, 0.05, 0.05);
            const woodMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 1,
                metalness: 0
            });
            
            // Create fence segments on all four sides
            const fenceDistance = 4.8; // Distance from center
            
            // Function to create a fence line
            function createFenceLine(startX, startZ, endX, endZ) {
                const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endZ - startZ, 2));
                const segments = Math.ceil(length / 2); // Post every 2 units
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = startX + t * (endX - startX);
                    const z = startZ + t * (endZ - startZ);
                    
                    // Add post
                    const post = new THREE.Mesh(postGeometry, woodMaterial);
                    post.position.set(x, 0.4, z); // Half height above ground
                    post.castShadow = true;
                    fenceGroup.add(post);
                    
                    // Add rails between posts (except for the last post)
                    if (i < segments) {
                        const nextT = (i + 1) / segments;
                        const nextX = startX + nextT * (endX - startX);
                        const nextZ = startZ + nextT * (endZ - startZ);
                        
                        // Calculate rail position and rotation
                        const railX = (x + nextX) / 2;
                        const railZ = (z + nextZ) / 2;
                        const angle = Math.atan2(nextZ - z, nextX - x);
                        
                        // Top rail
                        const topRail = new THREE.Mesh(railGeometry, woodMaterial);
                        topRail.position.set(railX, 0.6, railZ);
                        topRail.rotation.y = angle;
                        topRail.castShadow = true;
                        fenceGroup.add(topRail);
                        
                        // Bottom rail
                        const bottomRail = new THREE.Mesh(railGeometry, woodMaterial);
                        bottomRail.position.set(railX, 0.2, railZ);
                        bottomRail.rotation.y = angle;
                        bottomRail.castShadow = true;
                        fenceGroup.add(bottomRail);
                    }
                }
            }
            
            // Create four sides of the fence
            createFenceLine(-fenceDistance, -fenceDistance, fenceDistance, -fenceDistance); // Front
            createFenceLine(fenceDistance, -fenceDistance, fenceDistance, fenceDistance);   // Right
            createFenceLine(fenceDistance, fenceDistance, -fenceDistance, fenceDistance);   // Back
            createFenceLine(-fenceDistance, fenceDistance, -fenceDistance, -fenceDistance); // Left
            
            return fenceGroup;
        }
        
        // Add fences to the scene
        const fences = createFences();
        scene.add(fences);
        
        // Set up basic orbit controls manually
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationSpeed = 0.01;
        let autoRotate = true;
        let chickenModel = null;
        let cowModel = null; // Add variable for cow model
        
        // Function to create a fallback chicken if the GLTF model fails to load
        function createSimpleChicken() {
            const group = new THREE.Group();
            
            // Body - slightly elongated sphere
            const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            bodyGeometry.scale(1, 0.8, 1.2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            group.add(body);
            
            // Head - smaller sphere
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.1, 0.4);
            group.add(head);
            
            // Beak - cone
            const beakGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFFAA00 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 1.1, 0.7);
            group.add(beak);
            
            // Legs - cylinders
            const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0xFFAA00 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0.2, 0.25, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(-0.2, 0.25, 0);
            group.add(rightLeg);
            
            group.traverse(function(node) {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            return group;
        }
        
        // Create a fallback cow if the GLTF model fails to load
        function createSimpleCow() {
            const group = new THREE.Group();
            
            // Body - elongated box
            const bodyGeometry = new THREE.BoxGeometry(1.2, 0.7, 0.6);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.7;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.5);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.7, 1.1, 0);
            group.add(head);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            const positions = [
                [-0.4, 0.35, 0.2],  // front left
                [-0.4, 0.35, -0.2], // front right
                [0.4, 0.35, 0.2],   // back left
                [0.4, 0.35, -0.2],  // back right
            ];
            
            positions.forEach(position => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...position);
                group.add(leg);
            });
            
            group.traverse(function(node) {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            
            return group;
        }
        
        // First try to load the chicken.glb model
        try {
            const loader = new THREE.GLTFLoader();
            loader.load(
                'chicken.glb', // Path to your model in the same folder
                function (gltf) {
                    chickenModel = gltf.scene;
                    chickenModel.traverse(function (node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    // Center and scale the model as needed
                    // Adjust position to place chicken on top of the ground
                    chickenModel.scale.set(1, 1, 1);
                    
                    // Calculate bounding box to properly position the model
                    const bbox = new THREE.Box3().setFromObject(chickenModel);
                    const height = bbox.max.y - bbox.min.y;
                    // Position the bottom of the model exactly at ground level
                    chickenModel.position.y = Math.abs(bbox.min.y);
                    
                    scene.add(chickenModel);
                    
                    // Check for animations
                    if (gltf.animations && gltf.animations.length) {
                        const mixer = new THREE.AnimationMixer(chickenModel);
                        const action = mixer.clipAction(gltf.animations[0]);
                        action.play();
                        
                        // Update the animation in the render loop
                        const clock = new THREE.Clock();
                        function animateModel() {
                            mixer.update(clock.getDelta());
                        }
                        
                        // Add the animation function to our animate loop
                        const originalAnimate = animate;
                        animate = function() {
                            animateModel();
                            originalAnimate();
                        };
                    }
                    
                    // Hide loading text once the model is loaded
                    document.querySelector('.loading-text').style.display = 'none';
                },
                function (xhr) {
                    // Progress indicator
                    document.querySelector('.loading-text').textContent = 
                        'Loading model: ' + Math.floor(xhr.loaded / xhr.total * 100) + '%';
                },
                function (error) {
                    console.error('Error loading GLTF model:', error);
                    document.querySelector('.loading-text').textContent = 'Error loading model, using fallback';
                    
                    // If GLTF loading fails, use our simple chicken model as fallback
                    setTimeout(() => {
                        chickenModel = createSimpleChicken();
                        scene.add(chickenModel);
                        document.querySelector('.loading-text').style.display = 'none';
                    }, 1000);
                }
            );
        } catch (e) {
            console.error('GLTF Loader error:', e);
            // If there's an error with the loader itself, use the fallback model
            chickenModel = createSimpleChicken();
            scene.add(chickenModel);
            document.querySelector('.loading-text').style.display = 'none';
        }
        
        // Now try to load the cow.glb model
        try {
            const loader = new THREE.GLTFLoader();
            loader.load(
                'cow.glb', // Path to your model in the same folder
                function (gltf) {
                    cowModel = gltf.scene;
                    cowModel.traverse(function (node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    // Calculate bounding box to properly position the model
                    const bbox = new THREE.Box3().setFromObject(cowModel);
                    const height = bbox.max.y - bbox.min.y;
                    
                    // Position the cow next to the chicken, offset to the right
                    cowModel.position.y = Math.abs(bbox.min.y);
                    cowModel.position.x = 2.5; // Position to the right of center
                    cowModel.position.z = 1.5; // Position slightly back
                    cowModel.rotation.y = -Math.PI / 4; // Rotate the cow to face slightly toward the center
                    
                    scene.add(cowModel);
                    
                    // Check for animations
                    if (gltf.animations && gltf.animations.length) {
                        const mixer = new THREE.AnimationMixer(cowModel);
                        const action = mixer.clipAction(gltf.animations[0]);
                        action.play();
                        
                        // Update the animation in the render loop
                        const clock = new THREE.Clock();
                        function animateCowModel() {
                            mixer.update(clock.getDelta());
                        }
                        
                        // Add the animation function to our animate loop
                        const originalAnimate = animate;
                        animate = function() {
                            animateCowModel();
                            originalAnimate();
                        };
                    }
                },
                function (xhr) {
                    console.log("Loading cow: " + (xhr.loaded / xhr.total * 100) + "%");
                },
                function (error) {
                    console.error('Error loading cow model:', error);
                    
                    // If GLTF loading fails, use simple cow model as fallback
                    setTimeout(() => {
                        cowModel = createSimpleCow();
                        cowModel.position.set(2.5, 0, 1.5);
                        cowModel.rotation.y = -Math.PI / 4;
                        scene.add(cowModel);
                    }, 1000);
                }
            );
        } catch (e) {
            console.error('Cow GLTF Loader error:', e);
            // If there's an error with the loader itself, use the fallback model
            cowModel = createSimpleCow();
            cowModel.position.set(2.5, 0, 1.5);
            cowModel.rotation.y = -Math.PI / 4;
            scene.add(cowModel);
        }
        
        // Mouse controls
        document.addEventListener('mousedown', function(e) {
            isDragging = true;
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
            autoRotate = false;
        });
        
        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                // Rotate camera based on mouse movement
                const deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        toRadians(deltaMove.y * rotationSpeed),
                        toRadians(deltaMove.x * rotationSpeed),
                        0,
                        'XYZ'
                    ));
                
                camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
                
                previousMousePosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            }
        });
        
        document.addEventListener('mouseup', function() {
            isDragging = false;
        });
        
        // Convert degrees to radians
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Simple auto rotation for the model if it exists and auto-rotate is enabled
            if (chickenModel && autoRotate) {
                chickenModel.rotation.y += 0.01;
            }
            
            // Maybe slightly different rotation for the cow
            if (cowModel && autoRotate) {
                cowModel.rotation.y += 0.005; // Slower rotation
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>